# 数据通信网络基础


## 网络通信的基本概念

网络通信：终端设备通过计算机网络进行通信

# 应用层协议

## Http
——Http由两个程序实现：客户程序+服务器程序。 **它们运行在不同的端系统**
——Http定义了client向server发送web页面请求的方式，和server向client传送页面的方式

### http的特点

- http使用TCP作为运输支持协议，
- 是一个无状态协议（stateless protocol）
	- 就是说服务器不储存客户装载信息，你第二次来它不认识你
	- 然后就有cookie和session技术让服务器记人
- 默认采用持续连接
	- 持续连接：所有响应都经过一个相同的TCP连接
	- 非持续连接：每个响应有个自己的TCP连接
- 是一个双向协议

### http的报文格式

**请求报文**
![[Pasted image 20230518104721.png|400]]
![[Pasted image 20230518161535.png|500]]

#### 方法
**GET**: 用于client向服务器请求web页面
**POST**:client提交表单
	实际上这个功能似乎用GET实现更多 ，直接在URL中提交用户输入的数据
**HEAD**:和GET类似，服务器收到报文之后会对它进行响应，但不返回请求报文，用于调试跟踪
**PUT**:
**DELETE**:允许client或应用程序删除服务器上的对象

对get请求而言，在URL中添加字段会有大小上的限制
而post请求则不会对body做大小限制

![[Pasted image 20230518193155.png]]

#### 首部行常见字段
- Host ：客户端发送请求时，用来指定服务器的域名
- Connection：字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。



**响应报文**
![[Pasted image 20230518105342.png|400]]


#### 首部行常见字段
- Content-Length：服务器返回数据时，表明本次回应的数据长度



![[Pasted image 20230518163025.png]]
![[Pasted image 20230518163110.png]]
#### 常见状态码和含义
![[Pasted image 20230518191831.png]]


### cookie

#### cookie的组成

- http响应报文中的一个首部行
	`Set-cookie: 1678`
	浏览器受到这条信息后在它管理的cookie文件中添加一行（包括服务器主机名和识别码）
- http请求报文中的一个首部行
	`Cookies :1678`
	后面的数字是这个用户cookie的识别码。
	每请求一个Web 页面， ==浏览器==就会查询该cookie 文件并抽取对这个网站的识别码
- 用户端中保留的一个cookie文件（由浏览器进行管理）
- Web站点的一个后端数据库
- 
# WireShark 紧急学一下

- wireshark 有两种模式：普通模式和混杂模式
	- 在捕获/选项中进行更改（好像要暂停抓包才能用
	- 混杂模式就是啥包都给你抓
	- 普通模式会有一个过滤，只接收发送的正确的数据包

、

# 传输层 

## UDP协议
——它比较简单先略过

## TCP协议
——是在不可靠的IP层之上实现的可靠数据传输协议，解决了传输的可靠、有序、无丢失、不重复问题。
TCP 是每发送一个数据，都要进行一次确认应答

**特点：**
- 面向连接
- 一对一
- 提供可靠的服务
- 提供全双工通信
- 面向字节流

![[Pasted image 20230526095538.png|500]]
![[Pasted image 20230526095734.png]]

**如何建立一个TCP连接？**
-   **Socket**：由 IP 地址和端口号组成
-   **序列号**：用来解决乱序问题等
-   **窗口大小**：用来做流量控制

**如何唯一确定一个TCP连接？**
TCP 四元组可以唯一的确定一个连接，四元组包括如下：
-   源地址
-   源端口
-   目的地址
-   目的端口

——端口号的作用：用来区分同一台主机上不同应用程序的数据包


### 三次握手

**为什么是三次握手？**
-   三次握手才可以阻止重复历史连接的初始化（主要原因）
-   三次握手才可以同步双方的初始序列号
-   三次握手才可以避免资源浪费

### 四次挥手

——挥手能能改成三次？

### 重传机制

#### 超时重传

——设定一个定时器，超过指定时间没收到`ACK` 确认报文，就重发该数据

**什么时候会超时重传？**
- 数据包丢失
- 确认应答丢失

**rtt（round-trip time）**：数据发送到接收到确认的时刻的差值

**超时重传时间（RTO：Retransmission Timeout）应该设置为多长？**
- 太长时：网络的空隙时间增大，降低了网络传输效率
- 太短：不必要的重传导致网络负荷增大

**超时重传时间RTO应该略大于报文往返RTT的值**


但是！RTT的值时经常变化的
→RTO的值也是一个动态变化的值

---

#### 快速重传

——优化超时重传的相对周期较长的问题
——快速重传不以时间为驱动，而是以数据驱动重传

![[Pasted image 20230526141932.png]]

这个方法有一个问题：收到3个ACK之后，要重传哪几个报文

---

#### SACK方法

（ Selective Acknowledgment）选择性确认
——解决快速重传的问题
**在TCP头部条件一个SACK字段** 它将已经收到的数据的信息发送给发送方，发送方就可以zhi6重传丢失的数据

#### 滑动窗口

**TCP 是每发送一个数据，都要进行一次确认应答**导致包的往返时间越长，网络的吞吐量会越低（即通信效率变低）
——通过引入**窗口**这个概念来解决

**窗口大小**：无需等大确认应答，而可以继续发送数据的最大值

——其实质时操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果收到确认应答，此时数据可以从缓存区清除

**通常窗口的大小由接收方的窗口大小决定**


#### 流量控制

——一种让收发双方能根据实际接收能力控制发送的数据量



#### 拥塞控制

——避免发送方的数据填满整个网络

它是发送方维持的一个状态变量，根据网络的拥塞程度动态变化

**如何判断网络是否出现拥塞？**
发生超时重传则认为网络出现了拥塞

拥塞控制主要是四个算法：

-   慢启动
-   拥塞避免
-   拥塞发生
-   快速恢复

---

##### 慢启动

——**当发送方每收到一个ACK，拥塞窗口cwnd的大小就会×2**

**慢启动涨到多大是个头？**
- 慢启动门限 `ssthresh` （slow start threshold）状态变量。
	-  当 `cwnd` < `ssthresh` 时，使用慢启动算法。
	-   当 `cwnd` >= `ssthresh` 时，就会使用「拥塞避免算法」。

——一般来讲`ssthresh`的值为65535

##### 拥塞避免

——**每当收到一个ACK时，cwnd就+1**


##### 拥塞发生

分为**超时重传**时和**快速重传**时

超时重传时：
-   `ssthresh` 设为 `cwnd/2`，
-   `cwnd` 重置为 `1` （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）

**这种方法会造成网络卡顿**

快速重传时：
-   `cwnd = cwnd/2` ，也就是设置为原来的一半;
-   `ssthresh = cwnd`;
-   进入快速恢复算法

##### 快速恢复
-   拥塞窗口 `cwnd = ssthresh + 3` （ 3 的意思是确认有 3 个数据包被收到了）；
-   重传丢失的数据包；
-   如果再收到重复的 ACK，那么 cwnd 增加 1；
-   如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；
![[Pasted image 20230526151343.png]]

## TCP实例



# 网络层


