# 考试范围
第一章（10）
几个概念：什么是数据库、数据、数据库管理系统、数据库系统（理解，选择）
数据库什么时候诞生
数据库提供的三个语言
数据库的特点
几个模型，他们的区别，特点
题：画ER图

范式：必考
几个模式
第二章（10）
笛卡尔积
基数的概念：
属性那几个概念
关系数据库的6条性质
关系的完整性
几个运算（会算）

第六章（15分）

规范化：范式的定义，分别消除了什么（好像说会考原题）
公理系统的三个定理
怎么利用三大定理求闭包（建议看点课后题）
第七章（10）
怎么将ER模型转换成关系
实体转换为关系（就是几个表……最多，最少几个表，会有这样的题）

Oracle 这个考代码
第三章 数据库的创建和操作（20）
（就是一些基本操作）
创建表
修改表
删除数据

第四章 （15）
select
where
from
ordered by 
**group by** 
distinct 
百分号 ，下划线 like 

子查询
一些函数（最大值，最小值）
统计
（1：27：00 左右在讲难度到哪里）
排序
order by (升序，降序)

创建视图
建议看一下替换变量

第五章
看看例题（红书那个第六章为主）
外键

第六章
哪里有个五分编程题，函数/xx过程……还是啥
游标，怎么声明









例7.6  
  
例8.4  
Create grant revoke  
  
Audit  
第九章 问答  
为什么备份，还原；各有什么方法  
  
第十章   
事务的特性  
锁 有几种类型的锁  
死锁是什么




# 绪论

## 数据库系统概述

### 数据、数据库、数据库管理系统、数据库系统

**数据：** 数据库中存储的基本对象（可以有多种形式，比如文字、图像、图形等等，总之经过数字化处理后可以放计算力里面）

**数据库：** 长期存储在==计算机内、有组织、可共享的==大量数据的集合。
——数据库具有==永久存储、有组织、可共享== 三个基本特点

**数据库管理系统：** 有以下功能
	**1.数据定义** ：提供数据定义语言（DDL），用户通过它可以方便地对数据库中的数据对象进行定义
	**2.数据组织、存储和管理**：数据怎么放比较高效，放在计算机哪里，怎么调度数据
	**3.数据操纵功能**：增删查改等
	**4.数据库的事务管理和运行管理**：保证数据的完全性、完整性、
	**5.数据库的建立和维护功能**


**数据库系统：** 一般由数据库、数据库管理系统、应用系统、数据库管理员组成

![[Pasted image 20230617152424.png]]

### 数据库管理技术的产生和发展
——三个阶段：人工管理、文件系统、数据库系统

**人工管理阶段：**
	数据不保存
	应用程序管理数据 
	数据不共享
	数据不具有独立性

**文件系统阶段：**
	数据可以长期保存
	由文件系统管理数据
	缺点：数据共享性差，冗余度大；数据独立性差

**数据库系统阶段：**
	数据结构化
	数据共享性高，冗余度低，易扩充
	数据独立性高
	数据由DBMS统一管理和控制



## 数据模型
——对现实世界数据特征的抽象。数据模型就是现实世界的模拟。

### 两类数据模型

**数据模型应满足三方面要求：**
	能比较真实地模拟现实世界
	容易为人所理解
	便于在计算机上实现


#### 概念模型
——也称信息模型，它式按用户地观点来对数据和信息建模，主要用于数据库设计

#### 逻辑模型和物理模型

**逻辑模型**
——包括数据库以什么形式展现（它的结构是什么样的），包括层次模型、网状模型、关系模型、面向对象模型和对象关系模型……
**它是按计算机系统的观点对数据进行建模，主要用于DBMS的实现**


**物理模型**
对数据最底层的抽象，它描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法，**是面向计算机硬件的。**

### 数据模型的组成要素
——组成要素即在进行数据库设计时应明确哪些信息

数据模型通常由==数据结构==、==数据操作==和==完整性约束==三部分组成。

**数据结构：** 数据之间是什么样一种逻辑关系

**数据操作**： 增删查改

**数据的完整性约束条件：** 一组完整性规则，即数据应该合法

【例】在关系模型中，任何关系必须满足**实体完整性**和**参照完整性**两个条件

	－实体完整性：每一个数据都应该给设置一个key（一个编码或者其他什么东西）唯一确定一条记录

【例】如果规定70岁退休，则一个78岁的人不应该出现在在职人员表里面


### 概念模型
——感觉类似于你设想的这数据库长啥样。

#### 信息世界中的基本概念

**实体：** 现实中客观存在并可相互区别的事务称为实体。
**属性：** 实体所具有的某一特性。
 ——比如张三这个实体可以由身高体重性别年龄……一系列属性来描述
**码：** 唯一标识实体的==属性集==
——注意是属性集，就是说里面可以是一个或多个
**域：** 一个属性的取值范围
——比如学号这个属性的取值范围是整数 
**实体型：** 具有相同的属性的实体的==总称==
——比如上例的张三就属于“学生”这个实体型
**实体集：** 同一类型实体的集合
——全体学生就是一个实体集
**联系：** 联系在信息中介中反映为实体型内部和实体型外部
——比如班长和其它同学是内部；老师和学生是外部的

#### 两个实体型之间的联系

**一对一**

**一对多**
——可以讲一对一看成一对多的特例
**多对多**

#### 多个实体型之间的联系

#### 单个实体性内的联系

#### 概念模型的表示方法 E-R图（实体-联系图）

——ER图抽线出来的关系就是我们之前讲的概念模型


### 最常用的数据模型

——层次模型、网状模型、关系模型，还有其它的，但是这三个常用

### 关系模型

#### 几个概念
**关系**：就是一张二维表
**元组**：表中的一行
**属性**：表中的一列
**码**：可以唯一确定一个元组
**域**：属性的取值范围
**分量**：元组中的一个属性值
**关系模式**：对关系的描述
	表示为 <关系名>（属性1，属性2，属性3...）


#### 关系数据模型的操纵与完整性约束


**完整性约束包括三大类**
	实体完整性：能通过n个属性确定唯一的实体
	参照完整性：实体里的属性要参照另一个实体来设定，比如说学生实体和选修实体里的学号应该保持一致
	用户定义的完整性：数据应该合法。


#### 关系数据模型的优点

1.建立在严格的数学概念的基础上
2.关系模型的概念单一：便于操作
3.存取路径对用户透明，具有更高的数据独立性、更好的安全保密性，也简化了程序员的工作和数据库开发和建立的工作

### 数据库的系统结构

#### 数据库系统模式的概念

**模式（schema）**：是数据库中全体数据的逻辑结构和特征的描述，同一个模式可以有很多实例
——硬要说的话……你打开数据库软件会发现schema就是一张表


#### 数据库系统的三级模式结构

**外模式**：数据库给用户看的东西
**模式**：数据在数据库里的存储方式，感觉就是数据存储的数据结构
**内模式**：数据的硬件存储方式（存储在哪个文件夹、硬盘）


——外模式可以有多种
——一个应用程序只能用一个外模式
——外模式是保证数据库安全的有力措施


### 数据库系统的组成
——数据库、数据库管理系统、应用系统、数据库管理员





# 关系数据库

## 关系

- 单一的数据结构——关系
	-现实世界的实体以及实体间的各种联系均用关系来表示
- 逻辑结构——二维表
	从用户角度，关系模型中数据的逻辑结构是一张二维表

**关系模型是建立在集合代数的基础上**

几个概念：
**域**：一组具有相同数据类型的值的集合
**笛卡尔积**：每个域中选定一个值，这样的一组数据的所有可能的集合
**元组**：笛卡尔积中的每一个元素，称作一个n元组（乘出来的一个结果）
**分量**：一个记录中的一个值（一个结果中的一个）
**基数**：一个域中里取值的个数。结果的基址就是每个域的基数的乘积

**码：**
	候选码：能唯一确定一个元组的属性
	全码：所有属性都是候选码
	主码：若一个关系有多个候选码，则选定其中一个为主码
	主属性：候选码的诸属性
	非主属性：不包含在任何候选码中的属性

码和属性的区别在于：一个码可以由多个属性组成。

**三类关系**
	基本关系：实际存在的表，实际存储数据的逻辑表示
	查询表：查询结果对应的表
	视图表：由 基本表或其它视图表导出的表，是虚表，不对应实际存储的数据

**==基本关系的性质==**
	列是同质的：一列应该是同一个取值范围
	不同的列可以出自同一个域：比如性别和姓名都可以出自汉字这个集合
	列的顺序无所谓
	任意两个元组的候选码不能相同
	行的顺序无所谓，行的次序可以任意交换
	**分量必须取原子值**：就是不能表中有表
	![[Pasted image 20230617205932.png]]
	这样不行

### 关系模式
——对关系的描述，关系模式是型，关系是值。

**什么是关系模式**
	元组集合的结构
	一个关系通常由赋予它的元组语义确定
	现实的世界中还存在着完整性约束


**定义关系模式**
	R(U,D,DOM,F)
	R:关系名
	U：组成该关系的属性名集合
	D：属性组U中属性所来自的域
	DOM：属性向域的映像集合
	F：属性间的数据依赖关系集合

可以把关系模式理解成关系的模板


**关系模式与关系**
	关系模式是静态的、稳定的
	关系是动态的、随时间不断变化的

### 关系数据库
——在一个给定的应用领域中，所有关系的集合构成一个关系数据库

**关系数据库的型与值**
	型：关系数据库模式，对关系数据库的描述
	模式：若干域的定义，在这些域上定义的若干关系模式
	值：关系模式在某一时刻对应的关系的集合，简称为关系数据库


## 关系数据结构

### 基本关系操作

#### 常用的关系操作

**查询**：==选择、投影、并、差、笛卡尔积==为查询的五种基本操作
**数据更新**：插入、删除、修改

#### 关系操作的特点

——**集合操作方式：** 操作的对象和结果都是集合，一次一集合的方式
就是说它是集合带集合


## 关系的完整性

——**实体完整性**、**参照完整性**、用户定义完整性

==关系的两个不变性：== 实体完整性和参照完整性是关系模型**必须满足的约束条件**

**实体完整性：** 属性A是基本关系R的主属性，则属性A不能取空值
（不然就查无此实体了）

**参照完整性：**
	关系间的引用
	外码：若F是基本关系R的一个或一组属性，但不是关系R的码。如果F域基本关系S的主码K相对应，则称F是基本关系R的外码
	 基本关系R称为参照关系，基本关系S称为被参照关系或目标关系

【例】学生关系中每个元组的“专业号”属性只取两类值
（1）空值，表示尚未给该学生分配专业
（2）非空值，这时值必须是专业关系中某个元组的“专业号”值，表示**学生不可能分配一个不存在的专业**


## 关系代数

——关系代数按运算符可以分为**集合运算**和**专门运算**
**集合运算：** 从关系的水平方向，即行的角度进行
**专门运算：** 不仅涉及行而且涉及列

**集合运算运算符**
$\cup$ ：并
$-$ ：差
$\cap$ ：交
$\times$ ：笛卡尔积

**专门的关系运算符**
$\sigma$ :选择
$\pi$ :投影
▷◁ ：连接
$\div$ :除

### 传统的集合运算
——这个运算应该把一个元组看成一个整体

**并**
R和S具有相同的N个目，相应的属性取自同一个域
$R \cup S = \{t|t \in R \lor t \in S\}$
![[Pasted image 20230618193646.png]]

**差**
R和S具有相同的N个目，相应的属性取自同一个域
$R-S =\{t|t \in R \land t \notin S$ \}
![[Pasted image 20230618194317.png]]

**交**
R和S具有相同的N个目，相应的属性取自同一个域
$R \cup S = \{t|t \in R \land t \in S\}$
![[Pasted image 20230618194551.png]]

**笛卡尔积**
R，S可以有不同的属性


### 专门的关系运算

象集
![[Pasted image 20230618195824.png]]

**选择**
又称限制，在关系R中选择满足给定条件的诸元组，记作
${\sigma}_F ( R ) =\{t|T \in R \land F(t)= true \}$

——F为选择条件，比如 x>30 就是一个选择条件
![[Pasted image 20230618202906.png]]


**投影**
从R中选择出若干列组成新的关系
${\pi}_a(R)=\{t[A]|t \in R \}$
——$\pi$ 应该大写好像，但是没找到 算了
![[Pasted image 20230618203904.png]]

**连接**
又称 $\theta$ 连接   $\theta$ :比较运算符
![[Pasted image 20230618204318.png]]

等值连接：$\theta$ 为‘= 时’
![[Pasted image 20230618204818.png]]

  自然连接：等值连接的一种特殊情况
  两个关系中进行比较的分量必须时**相同属性组**（就是说名字要一样），在结果中把重复的属性列去掉（两个名字一样的只输出一行）

**几个概念**
	悬浮元组：没有加入到最后结果里的元组（被舍弃的元组）
	外连接:把舍弃的悬浮元组也添到结果表里，没有的写空值
	左外连接：只要R不符合条件的
	右外连接：只要S不符合条件的

![[Pasted image 20230618212217.png]]

**除**
给定关系R（X，Y）和S（Y，Z）其中X,Y,Z 为属性组，R和S中的属性Y可以有不同的属性名，但是必须出自相同的域集。
R与S的除运算得到一个新的关系P(X),P时R中满足下列关系的元组在X属性列上的投影
$R\div S=\{tr[X]|tr \in R \land{\pi}_{Y(s)}\subseteq Y_x$\}
$Y_x$ : x在R中的象集
![[Pasted image 20230618213955.png]]

  


## 课后习题

1.试述关系模型的三个组成部分
关系模型由**关系数据结构、关系操作集合、关系完整性约束**三部分组成。

2.试述关系数据语言的特点和分类
**关系代数语言、关系演算语言**，以及具有关系代数和关系演算双重特点的语言




# 关系数据库理论

## 问题的提出

**关系模式的表示**
——关系模式由五部分组成，是一个五元组 R（U，D，DOM，F）。

第一范式：每个分量必须是不可分开的数据项

**数据依赖**
——一个关系内部属性与属性之间的一种约束关系，是通过属性间值得相等与否体现出来的数据间相互联系

分为**函数依赖**和**多值依赖**


**函数依赖存在的问题** 
	数据冗余
	更新异常：冗余的信息有更新的时候，每条都要更新
	插入异常：
	删除异常：

**解决**
→用规范化的理论改造关系来消除其中不合适的数据依赖


## 规范化

### 函数依赖
——不同的规范化是为了解决不同的函数依赖

一般涉及函数依赖的是候选码

---
**一些术语和记号**
	非平凡函数依赖
	**例**（Sno, Cno)→grade   学号和课号能推出成绩，但成绩不属于学号和课号
	平凡函数依赖
	**例**（Sno, Cno)→Sno
	决定属性组/决定因素 X→Y 中的X

**我们讨论非平凡函数依赖** 平凡函数依赖没有意义

**完全函数依赖：**
知道X的所有属性才能推出Y

**部分函数依赖：**
知道X的一部分属性就能推出Y

**Z对X传递函数依赖**
在R（U）中，如果X→Y（非平凡） ，Y$\nrightarrow$ X  ，Y →Z （非平凡）则Z对X传递函数依赖
**例**：在关系Std（Sno，Sdept，Mname）中，有Sno→Sdept，Sdept→Mname，Mname传递函数依赖于Sno。

### 码
 
 **超码：** 候选码再加其它属性


**主属性与非主属性**
主属性：包含在任何一个候选码中的属性
非主属性：除了主属性都是非主属性
全码：整个属性组是码
外码：

**主码与外码一起提供了表关系间联系的手段**


### 范式
——符合某一种级别的关系模式的集合
就是一堆规则，符合这堆规则的就属于这个范式

**范式的分类**
	第一范式
	第二范式
	第三范式
	BC范式
	第四范式
	第五范式

范式间的关系——总之就是一个层层包含
![[Pasted image 20230620120628.png]]
 
#### 第一范式
——不能表中有表

#### 第二范式 
——每一个非主属性都**完全函数依赖**于任何一个候选码
就是说你的一个非主属性必须要找到一个候选码，这个非主属性只能由这个候选码的**全部**属性推出

![[Pasted image 20230620214519.png|300]]
这个不符合第二范式，所以要对它进行**模式分解**
——模式分解就是把一张大表拆成两个小表
![[Pasted image 20230620214436.png|300]]
像这样拆成两张表之后，就符合第二范式了

一个关系模式不属于2NF，会产生的问题：
（1）插入异常
（2）删除异常
（3）修改复杂

#### 第三范式
——R中不存在码X，属性组Y，非主属性Z，使得X→Y，Y→Z成立。
就是说不能由传递。（3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖）
![[Pasted image 20230620221215.png|300]]
上面的那张图拆成像这样的三张表


#### BC范式
——是对第三范式的一个修正/扩充。若X→Y，则X中必须含有码

BCNF的关系模式所具有的性质
（1）所有非主属性都完全函数依赖于每一个候选码
（2）所有主属性都完全函数依赖于每个不包含它的候选码
（3）没有任何属性完全函数依赖于非码的任何一组属性

**如果一个关系数据库的所有关系都属于BCNF，那么在函数依赖范畴里，它已经实现了模式发彻底分解，达到最高规范的程度，消除了插入异常和删除异常

#### 多值依赖

【例】 学校中某一门课程由多个教师讲授，他们使用相同的一套参考书，每个教员可以讲授多门课程，每种参考书可以供多门课使用。
用关系模式Teaching（C，T，B）来表示课程C、教师T和参考书B之间的关系。非规范化关系如下：
![[Pasted image 20230621184326.png]]
![[Pasted image 20230621184424.png|300]]
**以上关系存在下列问题：**
（1）数据冗余度大：有多少教师，参考书就存储多少次
（2）增加操作复杂：当某一课程增加一名任课教师时，该课程有多少本参考书，就必须插入多少个元组
（3）删除操作复杂：某一门课程要去掉一本参考书，该课程有多少名教师，就必须删除多少个元组
（4）修改操作复杂：某一门课要修改一本参考书，该课程有多少名教师，就必须修改多少个元组


**定义**：设R(U)是属性集U上的一个关系模式。X、Y、Z是U的子集，并且Z=U-X-Y。关系模式R(U)中多值依赖X→→Y成立，当且仅当对R(U)的任一关系r，给定的一对(x,y)值，有一组Y的值，这组值仅仅决定于x值而与z值无关。

【例】关系Teaching（C，T，B）中，对于C的每一个值，T有一组值与之对应，而不论B取何值。因此T多值依赖于C，即**C→→T**。


**多值依赖的性质：**
（1）多值依赖具有对称性：若X→→Y，则X→→Z，其中Z=U-X-Y。
（2)多值依赖具有传递性：X→→Y，Y→→Z，则X→→Z-Y
（3）函数依赖是多值依赖的特殊情况：若X→Y，则X→→Y。
（4）若X→→Y，X→→Z，则X→→Y∪Z
（5）若X→→Y，X→→Z，则X→→Y∩Z
（6）若X→→Y，X→→Z，则X→→Y-Z，X→→Z-Y

**多值依赖与函数依赖的区别：**
（1）多值依赖的有效性于属性集的范围有关
（2）


#### 第四范式
关系模式R<U ,F >$\in$ 1NF,如果对于R的每个非平凡多值依赖X→→Y(X不属于Y)，X都含有码，则R<U,F>为第四范式

## 数据依赖的公理系统

对于满足一组函数依赖F的关系模式R<U,F >,其任何一个关系r，若函数依赖X→Y都成立，（即r中任意两元组t、s，若t[X]=s[X]，则 t[Y]=s[Y]），则称F**逻辑蕴涵X →Y**。


### Armstrong公理系统
——一套推理规则
	求给定关系模式的码
	从一组函数依赖求得蕴涵的函数依赖

设U为属性集总体，**F是U上的一组函数依赖**，于是有关系模式R<U,F>,对R<U,F>来说有以下的推理规则

**自反律**：若$Y\subseteq X \subseteq U$，则X →Y 为F所蕴涵。
——自反律得到的函数依赖均是**平凡函数依赖**
**增广律**：若X→Y为F所蕴涵，且 $Z\subseteq U$，则XZ→YZ 为F所蕴涵。
**传递律**：若X→Y及Y→Z为F所蕴涵，则X→Z 为F所蕴涵。


**于是我们得到这样三条推理规则：**
合并规则（union rule）：由X→Y，X→Z，有X→YZ。
伪传递规则（pseudo transitivity rule）：  由X→Y，WY→Z，有XW→Z。
分解规则（decomposition rule）： 由X→Y及Z$\subseteq$Y，有X→Z。

引理6.1  X→A1 A2…Ak成立的充分必要条件是X→Ai成立（i=1，2，…，k）。
——X能推出大集合，那X就能推出每一个小集合

**闭包**：v在关系模式R<U,F>中为F所**逻辑蕴涵**的函数依赖的**全体**叫作F的闭包，记为F +。